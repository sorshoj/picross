<!DOCTYPE html>
<html>
<title>picross</title>

<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.15.1/dist/phaser-arcade-physics.min.js"></script>
</head>
<body>

    <script>



        class GameScene extends Phaser.Scene {
            constructor ()
            {
                super('GameScene');
                console.log('hit the constructor');

            }

            preload ()
            {
                // TODO move these loads to a different scene
                // these are reloaded every new game
                //this.load.image('square', 'square.png');
                this.load.image('square', 'square_v2.png');
                this.load.image('green', 'green_square.png');
                this.load.image('red', 'red.png');
                this.load.image('newgame', 'newgame.png');
                this.load.image('restart', 'restart.png');
                this.load.image('infobutton', 'info_button.png');
                console.log('hit the preload');


                // RESET VARIABLES FOR NEW GAME
                this.x = 10;
                this.y = 10;
                let a = this.boardgeneration(this.x, this.y);
                this.xclues = a[0];
                this.yclues = a[1];
                this.Board = a[2];
                this.board_green = a[3];
                
                this.player_green = 0;
                this.player_board = new Array(this.x*this.y);
            }

            // returns yclues, xclues, board array, and board_green
            boardgeneration (x, y) {

                let temp_yclues = new Array(y);
                let temp_xclues = new Array(x);
                let temp_board = new Array((x*y));
                let board_green = 0;

                // fill for edge cases
                for (let i = 0; i < y; i++) {
                    temp_yclues[i] = [0];
                }
                for (let i = 0; i < x; i++) {
                    temp_xclues[i] = [0];
                }


                let previous_row = []

                for (let i = 0; i < x; i++) {

                    let current_row = [];
                    for (let j = 0; j < y; j++) {
                        
                        // NUMBER SELECTION
                        let num = Math.floor(Math.random() * 2);

                        temp_board[(i*x)+j] = num;
                        current_row.push(num);

                        // CLUE LOGIC
                        if (num == 1) {

                            board_green += 1;

                            // 1. if temp_xclues[i] has a 0 (AKA empty)
                            // 2. if this is first val in current_row
                            // 3. if the prev val in current_row is 1
                            // 4. else push 1 to temp_xclues

                            let x_index = current_row.length - 1;

                            if (temp_xclues[i][0] == 0) {
                                temp_xclues[i][0] = 1;
                            } 
                            else if (x_index == 0) {
                                temp_xclues[i].push(1);
                            } 
                            else if (current_row[x_index-1] == 1) {                    
                                let xclues_index = temp_xclues[i].length - 1;
                                let x_clue = temp_xclues[i][xclues_index] + 1;
                                temp_xclues[i][xclues_index] = x_clue;
                            } 
                            else {
                                temp_xclues[i].push(1);
                            }


                            // 1. if temp_yclues[i] has a 0 (AKA empty)
                            // 2. if previous_row[j] is 1 & temp_yclues not empty
                            // 3. else push 1 to temp_yclues

                            if (temp_yclues[j][0] == 0) {
                                temp_yclues[j][0] = 1;
                            }
                            else if (previous_row[j] == 1 && temp_yclues[j].length != 0) {
                                let yclues_index = temp_yclues[j].length - 1;
                                let y_clue = temp_yclues[j][yclues_index] + 1;
                                temp_yclues[j][yclues_index] = y_clue;
                            } 
                            else {
                                temp_yclues[j].push(1);
                            }
                        }
                    }
                    previous_row = current_row;
                }

                console.log(temp_board.toString());

                // TODO what other assertions can be made?

                // ASSERTIONS
                console.assert(temp_yclues.length == y, "y clues are an incorrect length");
                console.assert(temp_xclues.length == x, "x clues are an incorrect length");

                return [temp_xclues, temp_yclues, temp_board, board_green];
            }

            create ()
            {                
                let start_x = 0;
                let start_y = 0;
                let square_length = 50;
                let margin = 150;
                let x = this.x;
                let y = this.y;
                let mod_val = (square_length*x);

                // create interactive image array
                for (let i = 0; i < this.Board.length; i++) {
                    let tent = this.add.image(start_x+margin, start_y+margin, 'square').setOrigin(0,0).setInteractive();
                    
                    tent.setData('index', i);
                    tent.setData('board', this.Board[i]);
                    tent.setData('found', 0);

                    tent.on('pointerdown', function(pointer) {
                        let index = this.getData('index');
                        let board = this.getData('board');
                        if (this.getData('found') == 0) {
                            if (pointer.rightButtonDown()) {
                                if(this.isTinted) {
                                    // remove tint
                                    this.clearTint();
                                } else {
                                    // grey
                                    this.setTint(0x828282);
                                }
                            } else {
                                if (board == 0) {
                                    // red
                                    this.setTint(0xff0000);
                                } else {
                                    // green
                                    this.setTint(0x05fa46);
                                }
                               this.setData('found', 1);
                            }
                        }
                    });

                    this.player_board[i] = tent;
                    start_x = (start_x + square_length) % mod_val;
                    if (start_x == 0){
                        start_y = start_y + square_length;
                    }
                }

                // add xclues to screen
                let ypos = margin + square_length/2;
                let xpos = margin / 3;
                for (let i = 0; i < this.xclues.length; i++) {
                    this.add.text(xpos, ypos, "" + this.xclues[i]);
                    ypos += square_length;
                }

                // add yclues to screen
                xpos = margin + square_length/2;
                for (let i = 0; i < this.yclues.length; i++) {
                    ypos = margin / 3;
                    for (let j = 0; j < this.yclues[i].length; j++){
                        this.add.text(xpos, ypos, "" + this.yclues[i][j]);
                        ypos+=20;
                    }
                    xpos += square_length;
                }


                // restart button
                let newgame_butt = this.add.image(config.width/2, config.height-100, 'newgame').setOrigin(0,0).setInteractive();
                newgame_butt.on('pointerdown', this.newgame, this);

                // info button
                let info_butt = this.add.image(config.width-100,config.height-100, 'infobutton').setOrigin(0,0).setInteractive();
                info_butt.on('pointerdown', function (pointer) {
                    this.scene.pause();
                    this.scene.run('InfoScene');
                }, this);


                // end scene
                this.input.on('pointerdown', function() {

                    // count the number of found green squares & compare
                    let green_count = 0;
                    let red_count = 0;
                    for (let i = 0; i < this.player_board.length; i++) {
                        if (this.player_board[i].getData('board') == 1) {
                            green_count += this.player_board[i].getData('found');
                        } else {
                            red_count += this.player_board[i].getData('found');
                        }
                    }

                    // add found green and red to registry
                    // end the game scene
                    if (green_count == this.board_green) {
                        this.scene.pause();
                        this.registry.set('board_green', this.board_green);
                        this.registry.set('player_red', red_count);
                        newgame_butt.setVisible(0);
                        this.scene.run('EndScene');
                    }
                }, this);

                // clue helper algo
                // TODO make optional in settings
                this.input.on('pointerdown', function() {
                    // check rows
                    for (let i = 0; i < this.x; i++) {
                        let all_green = 0;
                        let found_green = 0;
                        for (let j = 0; j < this.y; j++) {
                            if (this.Board[i*this.x + j] == 1) {
                                all_green += 1;
                                if (this.player_board[i*this.x + j].getData('found') == 1){
                                    found_green += 1;
                                }
                            }
                        }
                        // all green in row has been found
                        if (all_green == found_green) {
                            for (let j = 0; j < this.y; j++) {
                                if (this.player_board[i*this.x+j].getData('found') == 0){
                                    this.player_board[i*this.x+j].setTint(0x828282);
                                }
                            }
                        }
                    }

                    // check columns
                    for (let j = 0; j < this.y; j++) {
                        let all_green = 0;
                        let found_green = 0;
                        for (let i = 0; i < this.x; i++) {
                            if (this.Board[i*this.x + j] == 1) {
                                all_green += 1;
                                if (this.player_board[i*this.x + j].getData('found') == 1){
                                    found_green += 1;
                                }
                            }
                        }
                        // all green in row has been found
                        if (all_green == found_green) {
                            for (let i = 0; i < this.x; i++) {
                                if (this.player_board[i*this.x+j].getData('found') == 0){
                                    this.player_board[i*this.x+j].setTint(0x828282);
                                }
                            }
                        }
                    }

                }, this);

            }

            newgame ()
            {
                console.log('new game');
                this.scene.restart();
                return;
            }

        }

        class EndScene extends Phaser.Scene {
            constructor ()
            {
                super('EndScene');
            }
            preload() 
            {
                this.load.image('endscene', 'endscene.png');                
            }

            create ()
            {
                this.add.image(100, 100, 'endscene').setOrigin(0,0).setAlpha(0.5);

                // new game button
                let newgame_butt = this.add.image(config.width/2, config.height-100, 'newgame').setOrigin(0,0).setInteractive();
                newgame_butt.on('pointerdown', this.newgame, this);
                
                // add accuracy statistic aat end of game
                let board_green = this.registry.get('board_green');
                let player_red = this.registry.get('player_red');
                this.add.text(200, config.height-50, "Accuracy: " + Math.round(board_green/(player_red+board_green)*10000)/100 + "%");
            }
    
            newgame ()
            {
                console.log('new game');
                this.scene.start("GameScene");
            }
        }

        class InfoScene extends Phaser.Scene {
            constructor ()
            {
                super('InfoScene');
            }
            preload () {
                this.load.image('info', 'info.png');
            }
            create () {
                this.add.image(100, 100, 'info').setOrigin(0,0);
                this.input.once('pointerdown', this.disappear, this);

            }
            disappear () {
                this.scene.stop();
                this.scene.resume("GameScene");
            }
        }        


        var config = {
            type: Phaser.AUTO,
            width: 1000,
            height: 800,
            parent: 'phaser-example',
            scene: [ GameScene, EndScene, InfoScene]
        };

        var game = new Phaser.Game(config);
                
    </script>

</body>
</html>