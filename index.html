<!DOCTYPE html>
<html>
<title>picross</title>

<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.15.1/dist/phaser-arcade-physics.min.js"></script>
</head>
<body>

    <script>
        document.addEventListener("contextmenu", function (e){ 
                e.preventDefault();
            }, false);

        class GameScene extends Phaser.Scene {
            constructor ()
            {
                super('GameScene');
                console.log('hit the constructor');

            }

            preload ()
            {
                // TODO move these loads to a different scene
                // these are reloaded every new game

                this.load.image('square', 'assets/square_v2.png');
                this.load.image('newgame', 'assets/newgame_v2.png');
                this.load.image('infobutton', 'assets/info_button_v2.png');
                console.log('hit the preload');

                // RESET VARIABLES FOR NEW GAME
                this.x = 10;
                this.y = 10;
                this.margin = 150;
                this.square_length = 50;
                let a = this.boardgeneration(this.x, this.y);
                this.xclues = a[0];
                this.yclues = a[1];
                this.Board = a[2];
                this.board_green = a[3];
                this.registry.set('lastSquare', -1);
                
                this.player_green = 0;
                this.player_board = new Array(this.x*this.y);

                this.graphics = this.add.graphics();
                this.graphics.setDepth(100);
            }

            // returns yclues, xclues, board array, and board_green
            boardgeneration (x, y) {

                let temp_yclues = new Array(y);
                let temp_xclues = new Array(x);
                let temp_board = new Array((x*y));
                let board_green = 0;

                // fill for edge cases
                for (let i = 0; i < y; i++) {
                    temp_yclues[i] = [0];
                }
                for (let i = 0; i < x; i++) {
                    temp_xclues[i] = [0];
                }


                let previous_row = []

                for (let i = 0; i < x; i++) {

                    let current_row = [];
                    for (let j = 0; j < y; j++) {
                        
                        // NUMBER SELECTION
                        let num = Math.floor(Math.random() * 2);

                        temp_board[(i*x)+j] = num;
                        current_row.push(num);

                        // CLUE LOGIC
                        if (num == 1) {

                            board_green += 1;

                            // 1. if temp_xclues[i] has a 0 (AKA empty)
                            // 2. if this is first val in current_row
                            // 3. if the prev val in current_row is 1
                            // 4. else push 1 to temp_xclues

                            let x_index = current_row.length - 1;

                            if (temp_xclues[i][0] == 0) {
                                temp_xclues[i][0] = 1;
                            } 
                            else if (x_index == 0) {
                                temp_xclues[i].push(1);
                            } 
                            else if (current_row[x_index-1] == 1) {                    
                                let xclues_index = temp_xclues[i].length - 1;
                                let x_clue = temp_xclues[i][xclues_index] + 1;
                                temp_xclues[i][xclues_index] = x_clue;
                            } 
                            else {
                                temp_xclues[i].push(1);
                            }


                            // 1. if temp_yclues[i] has a 0 (AKA empty)
                            // 2. if previous_row[j] is 1 & temp_yclues not empty
                            // 3. else push 1 to temp_yclues

                            if (temp_yclues[j][0] == 0) {
                                temp_yclues[j][0] = 1;
                            }
                            else if (previous_row[j] == 1 && temp_yclues[j].length != 0) {
                                let yclues_index = temp_yclues[j].length - 1;
                                let y_clue = temp_yclues[j][yclues_index] + 1;
                                temp_yclues[j][yclues_index] = y_clue;
                            } 
                            else {
                                temp_yclues[j].push(1);
                            }
                        }
                    }
                    previous_row = current_row;
                }

                console.log(temp_board.toString());

                // TODO what other assertions can be made?

                // ASSERTIONS
                console.assert(temp_yclues.length == y, "y clues are an incorrect length");
                console.assert(temp_xclues.length == x, "x clues are an incorrect length");

                return [temp_xclues, temp_yclues, temp_board, board_green];
            }

            create ()
            {                
                let start_x = 0;
                let start_y = 0;
                let square_length = this.square_length;
                let margin = this.margin;
                let x = this.x;
                let y = this.y;
                let mod_val = (square_length*x);

                // create interactive image array
                // & click function
                for (let i = 0; i < this.Board.length; i++) {
                    let tent = this.add.image(start_x+margin, start_y+margin, 'square').setOrigin(0,0).setInteractive();
                    
                    tent.setData('index', i);
                    tent.setData('board', this.Board[i]);
                    tent.setData('found', 0);
    
                    this.player_board[i] = tent;
                    start_x = (start_x + square_length) % mod_val;
                    if (start_x == 0){
                        start_y = start_y + square_length;
                    }

                }


                // PLAYER INPUT
                //this.input.on('pointerdown', this.player_input, this);
                this.input.on('pointerdown', function(pointer, currentlyOver) {
                    
                    if (currentlyOver.length == 0) {
                        this.registry.set('lastSquare', -1);

                    } else {
                        let index1 = currentlyOver[0].getData('index')
                        this.registry.set('lastSquare', index1);
                    }
                }, this);

                this.input.on('pointerup', function(pointer, currentlyOver) {
                    if (currentlyOver.length == 0) {
                        return;
                    }
                    let currSquare = currentlyOver[0].getData('index')
                    let lastSquare = this.registry.get('lastSquare');

                    // case : same square ? 

                    if (lastSquare >= 0){
                        // either the same row
                        if (Math.abs(lastSquare-currSquare) <= 9){
                            // check if the same row

                            if (Math.floor(lastSquare/this.x) == Math.floor(currSquare/this.x)){
                                console.log("SAME ROW");

                                let squares = [];
                                for (let i = Math.min(lastSquare, currSquare); i <= Math.max(lastSquare, currSquare); i++){
                                    squares.push(i);
                                }
                                this.setAllTint(squares, pointer.rightButtonDown());
                            }
                        }
                        // or the same column
                        else if (lastSquare%this.y == currSquare%this.y) {
                            console.log("SAME COL");
                            //console.log(lastSquare, currSquare);

                            let squares = []
                            for (let i = Math.min(lastSquare, currSquare); i <= Math.max(lastSquare, currSquare); i+=this.x){

                                squares.push(i);
                            }

                            this.setAllTint(squares, pointer.rightButtonDown());
                        }
                        else {
                            console.log("NO MATCH");
                        }

                    }


                }, this);


                // add xclues to screen
                let ypos = margin + square_length/2;
                let xpos = margin / 3;
                for (let i = 0; i < this.xclues.length; i++) {
                    this.add.text(xpos, ypos, "" + this.xclues[i]);
                    ypos += square_length;
                }

                // add yclues to screen
                xpos = margin + square_length/2;
                for (let i = 0; i < this.yclues.length; i++) {
                    ypos = margin / 3;
                    for (let j = 0; j < this.yclues[i].length; j++){
                        this.add.text(xpos, ypos, "" + this.yclues[i][j]);
                        ypos+=20;
                    }
                    xpos += square_length;
                }


                this.draw_guidelines();
                this.guideline_butt = this.add.image(750,255, 'square').setOrigin(0,0).setInteractive();
                this.guideline_butt.setTint(0x1023ED);
                this.add.text(805, 275, 'Toggle Guidelines');
                this.guideline_butt.on('pointerdown', this.guidelines, this);


                // restart button
                let newgame_butt = this.add.image(config.width/2, config.height-100, 'newgame').setOrigin(0,0).setInteractive();
                newgame_butt.on('pointerdown', this.newgame, this);
                
                // clue helper algo (auto greys out when row/col completes)
                // TODO make optional in settings
                this.input.on('pointerup', function() {
                    // check rows
                    for (let i = 0; i < this.x; i++) {
                        let all_green = 0;
                        let found_green = 0;
                        for (let j = 0; j < this.y; j++) {
                            if (this.Board[i*this.x + j] == 1) {
                                all_green += 1;
                                if (this.player_board[i*this.x + j].getData('found') == 1){
                                    found_green += 1;
                                }
                            }
                        }
                        // all green in row has been found
                        if (all_green == found_green) {
                            for (let j = 0; j < this.y; j++) {
                                if (this.player_board[i*this.x+j].getData('found') == 0){
                                    this.player_board[i*this.x+j].setTint(0x828282);
                                    this.player_board[i*this.x+j].setData('found', 1);
                                }
                            }
                        }
                    }

                    // check columns
                    for (let j = 0; j < this.y; j++) {
                        let all_green = 0;
                        let found_green = 0;
                        for (let i = 0; i < this.x; i++) {
                            if (this.Board[i*this.x + j] == 1) {
                                all_green += 1;
                                if (this.player_board[i*this.x + j].getData('found') == 1){
                                    found_green += 1;
                                }
                            }
                        }
                        // all green in row has been found
                        if (all_green == found_green) {
                            for (let i = 0; i < this.x; i++) {
                                if (this.player_board[i*this.x+j].getData('found') == 0){
                                    this.player_board[i*this.x+j].setTint(0x828282);
                                    this.player_board[i*this.x+j].setData('found', 1);                                    
                                }
                            }
                        }
                    }

                }, this);  
                
                // info button
                let info_butt = this.add.image(config.width-100,config.height-100, 'infobutton').setOrigin(0,0).setInteractive();
                info_butt.on('pointerdown', function (pointer) {
                    this.scene.pause();
                    this.scene.run('InfoScene');
                }, this);


                // end scene button
                this.input.on('pointerdown', function() {

                    // count the number of found green squares & compare
                    let green_count = 0;
                    let red_count = 0;
                    for (let i = 0; i < this.player_board.length; i++) {
                        if (this.player_board[i].getData('board') == 1) {
                            green_count += this.player_board[i].getData('found');
                        } else {
                            red_count += this.player_board[i].getData('found');
                        }
                    }

                    // add found green and red to registry
                    // end the game scene
                    if (green_count == this.board_green) {
                        this.scene.pause();
                        this.registry.set('board_green', this.board_green);
                        this.registry.set('player_red', red_count);
                        newgame_butt.setVisible(0);
                        this.scene.run('EndScene');
                    }
                }, this);


            }

            newgame ()
            {
                console.log('new game');
                this.scene.restart();
                return;
            }

            setAllTint(squares, isGrey)
            {
                for (let i = 0; i < squares.length; i++) {
                    let currSquare = this.player_board[squares[i]];
                    console.log(currSquare.getData('index'));

                    if (currSquare.getData('found') == 0) {
                        if (isGrey) {
                            if (currSquare.isTinted) {
                                currSquare.clearTint();
                            } else {
                                // grey
                                currSquare.setTint(0x828282);
                            }
                        } else {
                            if (currSquare.getData('board') == 1) {
                                // green
                                currSquare.setTint(0x05fa46)
                            } else {
                                // red
                                currSquare.setTint(0xff0000);
                            }
                            currSquare.setData('found', 1);
                        }
                    }
                }
            }

            // listener for player input
            player_input(pointer, currentlyOver)
            {
                let margin = this.margin;
                let square_length = this.square_length;
                let x = this.x;
                let y = this.y;
                let tempx = Math.floor((pointer.x - margin) / square_length);
                let tempy = Math.floor((pointer.y - margin) / square_length);
                
                //console.log(currentlyOver);

                if ((pointer.x > margin & pointer.x < (margin+x*square_length)) & (pointer.y > margin & pointer.y < (margin+y*square_length))){
                    
                    //need to catch and limit pointer to only the board
                    let temp_index = tempx + tempy*y;

                    //console.log(temp_index);
                    let current_sq = this.player_board[temp_index]
                    let board = current_sq.getData('board');


                    if (current_sq.getData('found') == 0) {
                        console.log('FOUND')
                        if (pointer.leftButtonDown()) {
                            if (board == 0) {
                                // red
                                current_sq.setTint(0xff0000);
                            } else {
                                // green
                                current_sq.setTint(0x05fa46);
                            }
                            current_sq.setData('found', 1);                              
                        } else {
                            if(current_sq.isTinted) {
                                // remove tint
                                current_sq.clearTint();
                            } else {
                                // grey
                                current_sq.setTint(0x828282);
                            }                                
                        }
                    }                                     
                } else {
                    console.log('out of bounds');                        
                }
            }

            // listener function to toggle guidelines visibility
            guidelines() 
            {   
                if (!this.registry.has('guidelines')) {
                    this.registry.set('guidelines', 1);
                }
                if (this.registry.get('guidelines') == 0) {
                    this.registry.set('guidelines', 1);
                    this.graphics.setAlpha(1.0);
                    this.guideline_butt.setTint(0x1023ED);

                } else {
                    this.registry.set('guidelines', 0);
                    this.graphics.setAlpha(0.0);
                    this.guideline_butt.clearTint();
                }
                return;
            }

            // draws guidelines
            draw_guidelines ()
            {
                let square_length = 50;
                let margin = 150;

                this.graphics.lineStyle(3, 0x1023ED, 1.0);

                this.graphics.beginPath();
                this.graphics.lineBetween(margin+(square_length*this.x/2), margin-5,margin+(square_length*this.x/2), margin+(square_length*this.y)+5)
                this.graphics.lineBetween(margin-5, margin+(square_length*this.y/2), margin+(square_length*this.x)+5, margin+(square_length*this.y/2));
                this.graphics.closePath();
                this.graphics.strokePath();
                return;
            }

        }

        class EndScene extends Phaser.Scene {
            constructor ()
            {
                super('EndScene');
            }
            preload() 
            {
                this.load.image('endscene', 'assets/endscene_v2.png');                
            }

            create ()
            {
                this.add.image(100, 100, 'endscene').setOrigin(0,0).setAlpha(0.85);

                // new game button
                let newgame_butt = this.add.image(config.width/2, config.height-100, 'newgame').setOrigin(0,0).setInteractive();
                newgame_butt.on('pointerdown', this.newgame, this);
                
                // display accuracy statistic
                let board_green = this.registry.get('board_green');
                let player_red = this.registry.get('player_red');
                this.add.text(200, config.height-75, "Accuracy: " + Math.round(board_green/(player_red+board_green)*10000)/100 + "%");
            }
    
            newgame ()
            {
                console.log('new game');
                this.scene.start("GameScene");
            }
        }

        class InfoScene extends Phaser.Scene {
            constructor ()
            {
                super('InfoScene');
            }
            preload () {
                this.load.image('info', 'assets/infoscene_v2.png');
            }
            create () {
                this.add.image(100, 100, 'info').setOrigin(0,0).setAlpha(0.90);
                this.input.once('pointerdown', this.disappear, this);
            }
            disappear () {
                this.scene.stop();
                this.scene.resume("GameScene");
            }
        }        


        var config = {
            type: Phaser.AUTO,
            width: 1000,
            height: 800,
            parent: 'phaser-example',
            scene: [ GameScene, EndScene, InfoScene]
        };

        var game = new Phaser.Game(config);
                
    </script>


</body>
</html>