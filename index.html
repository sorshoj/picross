<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.15.1/dist/phaser-arcade-physics.min.js"></script>
</head>
<body>

    <script>

        // variable declaration
        const square_length = 100;
        const margin = 100;
        const x = 3;
        const y = 3;
        var count_squares = 0;
        var count_hit_red = 0;
        var count_green = 0;
        //var Board = new Array(x);
        //var player_board = new Array(x*y);
        // describe a row
        //var xclues = new Array(x);
        // describe a column
        //var yclues = new Array(y);

        class GameScene extends Phaser.Scene {
            constructor ()
            {
                super('GameScene');
                console.log('hit the constructor');

            }

            preload ()
            {
                // TODO move these loads to a different scene
                // these are reloaded every new game
                this.load.image('square', 'square.png');GameScene
                this.load.image('green', 'green_square.png');
                this.load.image('red', 'red.png');
                this.load.image('newgame', 'newgame.png');
                this.load.image('restart', 'restart.png');
                this.load.image('infobutton', 'info_button.png');
                console.log('hit the preload');


                //player_board = new Array(x*y);
                count_squares = 100;
                //count_hit_red = 0;
                //count_green = 0;

                // RESET VARIABLES FOR NEW GAME
                let a = this.boardgeneration(x, y);
                this.xclues = a[0];
                this.yclues = a[1];
                this.Board = a[2];
                this.board_green = a[3];
                
                this.player_green = 0;

                this.player_board = new Array(x*y);
            }


            boardgeneration1 () {
                Board = new Array(x*y);
                for (let i = 0; i < x*y; i++) {
                    let num = Math.floor(Math.random() * 2);
                    Board[i] = num;
                }
                console.log(Board.toString());
            }

            boardgeneration (x, y) {

                let temp_yclues = new Array(y);
                let temp_xclues = new Array(x);
                let temp_board = new Array((x*y));
                let board_green = 0;

                // fill for edge cases
                for (let i = 0; i < y; i++) {
                    temp_yclues[i] = [0];
                }
                for (let i = 0; i < x; i++) {
                    temp_xclues[i] = [0];
                }


                let previous_row = []

                for (let i = 0; i < x; i++) {

                    let current_row = [];
                    for (let j = 0; j < y; j++) {
                        
                        // NUMBER SELECTION
                        let num = Math.floor(Math.random() * 2);

                        temp_board[(i*x)+j] = num;
                        current_row.push(num);

                        // CLUE LOGIC
                        if (num == 1) {

                            board_green += 1;

                            // 1. if temp_xclues[i] has a 0 (AKA empty)
                            // 2. if this is first val in current_row
                            // 3. if the prev val in current_row is 1
                            // 4. else push 1 to temp_xclues

                            let x_index = current_row.length - 1;

                            if (temp_xclues[i][0] == 0) {
                                temp_xclues[i][0] = 1;
                            } 
                            else if (x_index == 0) {
                                temp_xclues[i].push(1);
                            } 
                            else if (current_row[x_index-1] == 1) {                    
                                let xclues_index = temp_xclues[i].length - 1;
                                let x_clue = temp_xclues[i][xclues_index] + 1;
                                temp_xclues[i][xclues_index] = x_clue;
                            } 
                            else {
                                temp_xclues[i].push(1);
                            }


                            // 1. if temp_yclues[i] has a 0 (AKA empty)
                            // 2. if previous_row[j] is 1 & temp_yclues not empty
                            // 3. else push 1 to temp_yclues

                            if (temp_yclues[j][0] == 0) {
                                temp_yclues[j][0] = 1;
                            }
                            else if (previous_row[j] == 1 && temp_yclues[j].length != 0) {
                                let yclues_index = temp_yclues[j].length - 1;
                                let y_clue = temp_yclues[j][yclues_index] + 1;
                                temp_yclues[j][yclues_index] = y_clue;
                            } 
                            else {
                                temp_yclues[j].push(1);
                            }
                        }
                    }

                    previous_row = current_row;

                }

                console.log(temp_board.toString());

                // TODO what other assertions can be made?

                // ASSERTIONS
                console.assert(temp_yclues.length == y, "y clues are an incorrect length");
                console.assert(temp_xclues.length == x, "x clues are an incorrect length");

                return [temp_xclues, temp_yclues, temp_board, board_green];
            }


            create ()
            {                
                let start_x = 0;
                let start_y = 0;
                let mod_val = (square_length*x);

                // create interactive image array
                for (let i = 0; i < this.Board.length; i++) {
                    let tent = this.add.image(start_x+margin, start_y+margin, 'square').setOrigin(0,0).setInteractive();
                    
                    tent.setData('index', i);
                    tent.setData('board', this.Board[i]);
                    tent.setData('found', 0);

                    tent.on('pointerdown', function(pointer) {
                        let index = this.getData('index');
                        let board = this.getData('board');
                        if (this.getData('found') == 0) {
                            if (pointer.rightButtonDown()) {
                                if(this.isTinted) {
                                    // remove tint
                                    this.clearTint();
                                } else {
                                    // grey
                                    this.setTint(0x828282);
                                }
                            } else {
                                if (board == 0) {
                                    // red
                                    this.setTint(0xff0000);
                                } else {
                                    // green
                                    this.setTint(0x05fa46);
                                }
                               this.setData('found', 1);
                            }
                        }
                    });

                    this.player_board[i] = tent;
                    start_x = (start_x + square_length) % mod_val;
                    if (start_x == 0){
                        start_y = start_y + square_length;
                    }
                }

                // add xclues to screen
                let ypos = margin + square_length/2;
                let xpos = margin / 3;
                for (let i = 0; i < this.xclues.length; i++) {
                    this.add.text(xpos, ypos, "" + this.xclues[i]);
                    ypos += square_length;
                }

                // add yclues to screen
                xpos = margin + square_length/2;
                ypos = margin / 3;
                for (let i = 0; i < this.yclues.length; i++) {
                    this.add.text(xpos, ypos, "" + this.yclues[i]);
                    xpos += square_length;
                }


                // restart button
                let newgame_butt = this.add.image(350, 525, 'newgame').setOrigin(0,0).setInteractive();
                newgame_butt.on('pointerdown', this.newgame, this);

                let info_butt = this.add.image(700,500, 'infobutton').setOrigin(0,0).setInteractive();
                info_butt.on('pointerdown', function (pointer) {
                    this.scene.pause();
                    this.scene.run('InfoScene');
                }, this);


                // end scene
                this.input.on('pointerdown', function() {

                    // count the number of found green squares & compare
                    let green_count = 0;
                    let red_count = 0;
                    for (let i = 0; i < this.player_board.length; i++) {
                        if (this.player_board[i].getData('board') == 1) {
                            green_count += this.player_board[i].getData('found');
                        } else {
                            red_count += this.player_board[i].getData('found');
                        }
                    }
                    if (green_count == this.board_green) {
                        this.scene.pause();
                        this.registry.set('board_green', this.board_green);
                        this.registry.set('player_red', red_count);
                        newgame_butt.setVisible(0);
                        this.scene.run('EndScene');
                    }
                    console.log(green_count);
                }, this);


            }

            newgame ()
            {
                console.log('new game');
                this.scene.restart();
            }

        }

        class EndScene extends Phaser.Scene {
            constructor ()
            {
                super('EndScene');
            }
            preload() 
            {
                this.load.image('endscene', 'endscene.png');                
            }

            create ()
            {
                this.add.image(100, 100, 'endscene').setOrigin(0,0).setAlpha(0.5);

                // new game button
                let newgame_butt = this.add.image(500, 525, 'newgame').setOrigin(0,0).setInteractive();
                newgame_butt.on('pointerdown', this.newgame, this);
                
                // add accuracy statistic aat end of game
                let board_green = this.registry.get('board_green');
                let player_red = this.registry.get('player_red');
                this.add.text(200, 550, "Accuracy: " + Math.round(board_green/(player_red+board_green)*10000)/100 + "%");
                //this.add.text(200, 550, "Accuracy: " + Math.round(count_green/(count_hit_red+count_green)*10000)/100 + "%");
            }
    
            newgame ()
            {
                console.log('new game');
                this.scene.start("GameScene");
            }
        }

        class InfoScene extends Phaser.Scene {
            constructor ()
            {
                super('InfoScene');
            }
            preload () {
                this.load.image('info', 'info.png');
            }
            create () {
                this.add.image(100, 100, 'info').setOrigin(0,0);
                this.input.once('pointerdown', this.disappear, this);

            }
            disappear () {
                this.scene.stop();
                this.scene.resume("GameScene");
            }
        }

        function generate_yclues ()
        {
            let index = 0;
            let count = 0;
            let col = new Array();
            for (let i = 0; i < Board.length; i++) {
                if (Board[index] == 1) {
                    count += 1;
                } else {
                    if (count > 0) {
                        col.push(count);
                    }
                    count = 0;
                }

                index += x;
                if (index >= Board.length) {
                    // first push remaining count to col
                    if (count > 0 | col.length == 0) {
                        col.push(count);
                    }
                    yclues.push(col);
                    col = new Array();
                    count = 0;
                    index = index - Board.length + 1;
                }
            }
            console.log(yclues);
        }

        function generate_xclues () 
        {
            let count = 0;
            let row = new Array();
            for (let i = 0; i < Board.length; i++) {
                if (Board[i] == 1) {
                    count += 1;
                } else {
                    if (count > 0) {
                        row.push(count);
                    }
                    count = 0;
                }
                if (i % x == x-1){
                    if (count > 0) {
                        row.push(count);
                    } 
                    if (row.length == 0) {
                        row.push(0);
                    }
                    xclues.push(row);
                    row = new Array();
                    count = 0;
                }
            }
            console.log(xclues);
        }

        


        var config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            parent: 'phaser-example',
            scene: [ GameScene, EndScene, InfoScene]
        };

        var game = new Phaser.Game(config);
                
    </script>

</body>
</html>